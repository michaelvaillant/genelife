<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Jeu de la Vie avec G√©nome Int√©gr√© et Graphique</title>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<link rel="stylesheet" href="https://www.u-sphere.com/data/life/life.css">
<style>
    .tmp_move {
        background-color: yellow;
    }
    .gene.actionRule {
        border-radius: 10px 0px 0px 10px;
        margin-right: 0px;
        padding-right: 9px;
        border-right: none;
    }
    .gene.tmp_move {
        border-radius: 0px 10px 10px 0px;
    }
    .gene {white-space: nowrap;}
</style>
<div id="controls">
    Seed<input id="seed" type="text" value="">    
    Turn<span id="round">0</span>
    Wait<input id="speed" type="text" value="">  

    Board<select id="board"> 
        <option value="16">16</option>
        <option value="32">32</option>
        <option value="64" default>64</option>
        <option value="128">128</option>
        <option value="256">256</option>
    </select>
    <div class="actions">
        <button id="clear" >Clear</button>
        <button id="Reset" >Reset</button>
    </div>
</div>

<div style="position: relative;">
    <canvas id="gameCanvas" width="1024" height="1024"></canvas>
    <canvas id="overlayCanvas" width="1024" height="1024" ></canvas>

    <div id="infoDiv">
        <div id="CellInfo">
            <div class="CellInfoTitle">üö© Location</div>
            <div id="CellInfoContent"></div>
            <div id="cellProxy"></div> 
        </div>

        <div id="genomeInfo" style="display: none;">
            <div class="genomeInfoTitle">üß¨ Genome</div>
            <div class="genomeInfoContent">
                <div class="genome-section" id="survivalSection">
                    <div class="genome-title">Survival</div>
                    <div class="horizontal-gene" id="survivalColumn"></div>
                </div>
                <div class="genome-section" id="birthSection">
                    <div class="genome-title">Birth</div>
                    <div class="horizontal-gene" id="birthColumn"></div>
                </div>
                <div class="genome-section" id="moveSection">
                    <div class="genome-title">Movement</div>
                    <div class="vertical-gene" id="moveColumn"></div>                    
                </div>
                <div class="genome-section" id="actionSection" style="display: none;">
                    <div class="genome-title">ActionRules</div>
                    <div class="vertical-gene" id="actionColumn"></div>
                </div>                
            </div>
        </div>
        <button id="copyButton" style="display: none; margin-top: 10px;">Copy</button>
    </div>			
</div>	

<!-- Fen√™tre modale -->
<div id="resetModal" class="modal" style="display:none;">
    <div class="modal-content">
      <h2>World Selection</h2>
      <form id="resetForm">
        <label><input type="radio" id="randomOption" name="seedOption" value="random"> Random seed</label>
        <label><input type="radio" id="currentOption" name="seedOption" value="current"> Seed <span id="currentSeedOption"></span></label>
        <label><input type="radio" id="world_0" name="seedOption" value="0"> World 1</label>
        <!-- Ajoutez ici plus d'options pour les autres mondes -->
      </form>
      <button id="cancelReset"> ‚ùå Cancel</button>
      <button id="applyReset">‚úîÔ∏è Reset</button>
    </div>
</div>

<canvas id="graphCanvas" width="1024" height="200"></canvas>
<div id="copiedAreaDiv"></div>

<script>
  class GameOfLife {
    constructor(config = {}) {
        // Canvas elements
        this.gameCanvas = document.getElementById('gameCanvas');
        this.ctx = this.gameCanvas.getContext('2d');
        this.overlayCanvas = document.getElementById('overlayCanvas');
        this.overlayCtx = this.overlayCanvas.getContext('2d');
        this.graphCanvas = document.getElementById('graphCanvas');
        this.graphCtx = this.graphCanvas.getContext('2d');

        // R√©f√©rences aux √©l√©ments de la modale
        this.resetModal = document.getElementById('resetModal');
        this.resetForm = document.getElementById('resetForm');
        this.applyResetButton = document.getElementById('applyReset');
        this.cancelResetButton = document.getElementById('cancelReset');
        this.currentSeedOption = document.getElementById('currentSeedOption');

        // Configuration parameters
        this.gridSize = config.gridSize || 64;
        this.cellSize = this.gameCanvas.width / this.gridSize;
        this.speed = config.speed || 100;
        this.seed = config.seed || Math.floor(Math.random() * 100000);
        this.isPaused = false;
        this.generationCount = 0;
        this.maxGenerations = 500;
        this.populationCounts = [];
        this.energyCounts = [];

        // Grids for the game
        this.currentGrid = this.createGrid(this.gridSize);
        this.nextGrid = this.createGrid(this.gridSize);

        // Events and controls
        this.hoveredCell = null;
        this.selectedCell = null;
        this.isAreaSelected = false;
        this.isDragging = false;
        this.draggedArea = null;
        this.isSelecting = false;
        this.startX = null;
        this.startY = null;
        this.endX = null;
        this.endY = null;
        this.dashOffset = 0;
        this.isAnimationRunning = false;
        this.copiedAreas = [];
        this.idAnim = null;

        // Selected area
        this.selectedArea = null;

        // Reference to HTML elements
        this.infoDiv = document.getElementById('infoDiv');
        this.CellInfoContent = document.getElementById('CellInfoContent');
        this.genomeInfo = document.getElementById('genomeInfo');
        this.survivalColumn = document.getElementById('survivalColumn');
        this.birthColumn = document.getElementById('birthColumn');
        this.moveColumn = document.getElementById('moveColumn');
        this.cellProxy = document.getElementById('cellProxy');
        this.copyButton = document.getElementById('copyButton');
        this.copiedAreaDiv = document.getElementById('copiedAreaDiv');

        // Patterns and genomes
        this.patterns = []; // Will store all patterns
        this.genomeTypes = {}; // Will store genome definitions

        // Pre-recorded worlds
        this.worlds = [
          {
            name: "World 1",
            grid: [
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
          }
        ];
    
        // Initialize the game
        this.initGame();
        this.bindEvents();
    }

    // ------------------------------------------------
    //                   INIT
    // ------------------------------------------------

    initGame() {
        Math.seedrandom(this.seed);
        this.updateControls();
        this.initializeGridWithObstacles();
        this.drawGrid(this.currentGrid);
        this.generationCount = 0;
        setTimeout(() => this.update(), this.speed);
        // Define genomes and patterns
        this.defineGenomes();
        this.definePatterns();
        // Preload patterns
        this.preloadPatterns();
    }

    updateControls() {
        document.getElementById('round').innerText = '0';
        document.getElementById('seed').value = this.seed;
        document.getElementById('board').value = this.gridSize;
        document.getElementById('speed').value = this.speed;
    }

    // ------------------------------------------------
    //                 GRIDS & CELLS
    // ------------------------------------------------

    createGrid(size) {
      const grid = new Array(size);
      for (let y = 0; y < size; y++) {
        grid[y] = new Array(size);
        for (let x = 0; x < size; x++) {
          grid[y][x] = this.createEmptyCell();
        }
      }
      return grid;
    }

    // On retire la propri√©t√© "actionRules" du cell,
    // puisque maintenant elles sont stock√©es dans le genome.
    createEmptyCell() {
      return { 
        age: -1, 
        state: 0, 
        genome: null, 
        energy: 0, 
        energyLeft: 0,
        actionValues: Array(8).fill(0) // On garde actionValues ici si on veut.
      };
    }

    copyGrid(sourceGrid) {
      const size = sourceGrid.length;
      const newGrid = new Array(size);
      for (let y = 0; y < size; y++) {
        newGrid[y] = new Array(size);
        for (let x = 0; x < size; x++) {
          newGrid[y][x] = this.deepCloneCell(sourceGrid[y][x]);
        }
      }
      return newGrid;
    }

    // ------------------------------------------------
    //                 INITIAL SETUP
    // ------------------------------------------------

    initializeGridWithObstacles() {
      this.initializeGrid(this.currentGrid);
      this.addCrossObstacles(this.currentGrid);
      this.drawGrid(this.currentGrid);
    }

    // Initialise la grille avec des cellules vivantes al√©atoires
    initializeGrid(grid) {
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
          if (Math.random() < 0.2) {
            grid[y][x].age = 0;
            grid[y][x].state = 1;
            grid[y][x].genome = this.generateRandomGenome();
            grid[y][x].energy = 100;
          }
        }
      }
    }

    // ------------------------------------------------
    //        GENOME & RANDOM GENERATION
    // ------------------------------------------------

    // -- AJOUT de actionRules dans le genome
    generateRandomGenome() {  // <-- Modif
        const directions = [1, 2, 3, 4];
        let moveRules = [];
        let survivalRules = [];
        let birthRules = [];
        let actionRules = [
            [5], [6], [7], [8], // Energy in N, S, E, W (one-shot moves)
            [5], [6], [7], [8]  // Cells in N, S, E, W (one-shot moves)
        ];

        let mover = false;
        
        // "Pac-Man" (yellow cells)
        if (Math.random() < 0.05) {
            survivalRules = [0, 1, 2, 3, 4, 5, 6, 7];
            moveRules = Array(24)
                .fill()
                .map(() => directions[Math.floor(Math.random() * directions.length)]);
            
            return { survivalRules, birth: birthRules, moveRules, actionRules };
        }

        // "Movers" (orange cells)
        if (Math.random() < 0.1) {
            let numInstructions = Math.floor(Math.random() * 1 + 1);
            for (let i = 0; i < numInstructions; i++) {
                const direction = directions[Math.floor(Math.random() * directions.length)];
                moveRules.push(direction);
            }
            mover = true;
        }


        // Survival Rules
        // let survivalConditions = mover ? [2, 3, 4] : [2, 3, 4];
        // survivalRules = [2, 3];         // root rules
        // survivalRules.push(survivalConditions[Math.floor(Math.random() * survivalConditions.length)]);
        // survivalRules.push(survivalConditions[Math.floor(Math.random() * survivalConditions.length)]);
        for (let i = 0; i < Math.floor(Math.random() * 5+1); i++) {
            survivalRules.push(Math.floor(Math.random() * 5+1));
        }        

        // Birth Rules
        birthRules.push([2, 3, 4, 5][Math.floor(Math.random() * 4)]);

        // On retourne un genome incluant actionRules
        return {
            survivalRules,
            birth: birthRules,
            moveRules,
            actionRules 
        };
    }

    // ------------------------------------------------
    //        DESSIN & OBSTACLES
    // ------------------------------------------------

    addCrossObstacles(grid) {
      const mid = Math.floor(this.gridSize / 2);
      const length = Math.floor(this.gridSize / 3);
      for (let x = mid; x < mid + length; x++) {
        grid[mid][x].state = -1;
      }
      for (let y = mid; y < mid + length; y++) {
        grid[y][mid].state = -1;
      }
      for (let y = mid - length; y < mid; y++) {
        grid[y][mid].state = -1;
      }
      for (let x = mid - length; x < mid; x++) {
        grid[mid][x].state = -1;
      }
    }

    drawGrid(grid) {
      this.ctx.clearRect(0, 0, this.gameCanvas.width, this.gameCanvas.height);
      for (let y = 0; y < this.gridSize; y++) {
        for (let x = 0; x < this.gridSize; x++) {
          const cell = grid[y][x];
          if (cell.state === 1) {
            const colorValue = Math.max(0, 255 - cell.age);
            if (cell.genome.moveRules.length > 0 && cell.genome.moveRules[0]) {
              if (cell.genome.birth[0]) {
                this.ctx.fillStyle = `rgb(${colorValue}, ${colorValue / 2}, 0)`;
              } else {
                this.ctx.fillStyle = `rgb(${colorValue}, ${colorValue}, 0)`;
              }
            } else {
              this.ctx.fillStyle = `rgb(${colorValue}, 0, 0)`;
            }
            this.ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
          } else if (cell.state === -1) {
            this.ctx.fillStyle = 'grey';
            this.ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
          } else if (cell.energyLeft > 0) {
            const energyRatio = cell.energyLeft / 10;
            const cValue = Math.floor(energyRatio * 255);
            this.ctx.fillStyle = `rgb(0, ${cValue}, 0)`;
            const energySize = this.cellSize / 2;
            this.ctx.fillRect(
              x * this.cellSize + this.cellSize / 4,
              y * this.cellSize + this.cellSize / 4,
              energySize,
              energySize
            );
          }
        }
      }
    }

    // ------------------------------------------------
    //            BOUCLE PRINCIPALE
    // ------------------------------------------------

    update() {
      if (this.isPaused) {
        setTimeout(() => this.update(), this.speed);
        return;
      }

      this.generationCount++;
      document.getElementById('round').innerText = `${this.generationCount}`;

      this.nextGrid = this.createGrid(this.gridSize);

      this.handleMovements();
      this.handleSurvivalAndReproduction();

      [this.currentGrid, this.nextGrid] = [this.nextGrid, this.currentGrid];
      this.drawGrid(this.currentGrid);

      this.updateGraphData();
      this.drawGraph();

      setTimeout(() => this.update(), this.speed);
    }

    // ------------------------------------------------
    //         MOUVEMENTS & ACTION RULES
    // ------------------------------------------------

    // Calcule les "scores" dans cell.actionValues, puis choisit la plus forte,
    // et va piocher la sous-liste de directions correspondante dans le genome.actionRules
    handleMovements() {
      let movementIntents = {};
      for (let y = 0; y < this.gridSize; y++) {
        for (let x = 0; x < this.gridSize; x++) {
          const cell = this.currentGrid[y][x];
          if (cell.state === 1) {
            // console.log(cell)
            this.calculateActionRules(cell, this.currentGrid, x, y);
            this.selectDominantAction(cell); // On va utiliser genome.actionRules

            // Comme avant, on consomme la 1re direction de moveRules
            // const dir = cell.genome.moveRules.shift();
            const dir = cell.genome.moveRules[0];
            const [dx, dy] = this.getDirectionOffset(dir);
            const targetX = (x + dx + this.gridSize) % this.gridSize;
            const targetY = (y + dy + this.gridSize) % this.gridSize;

            const targetKey = `${targetX},${targetY}`;
            if (!movementIntents[targetKey]) {
              movementIntents[targetKey] = [];
            }
            movementIntents[targetKey].push({ x, y, cell });
          }
        }
      }
      this.resolveMovementConflicts(movementIntents);
    }

    // On cherche l'indice de la plus forte actionValue, 
    // puis on ajoute le tableau d'actions correspondant dans cell.genome.moveRules.
    selectDominantAction(cell) { // <-- Modif

        // Idem : si pas de actionValues ou pas de actionRules ‚Üí rien √† faire
        if (!cell.genome?.actionRules || !cell.actionValues) {
            return;
        }

        const maxIndex = cell.actionValues.indexOf(Math.max(...cell.actionValues));

        // On va piocher dans cell.genome.actionRules, pas cell.actionRules
        if (
            cell.genome.actionRules && 
            cell.genome.actionRules[maxIndex] && 
            cell.genome.actionRules[maxIndex].length > 0
            ) {
            cell.genome.moveRules.push(...cell.genome.actionRules[maxIndex]);
        }
    }

    // On laisse l'√©criture dans cell.actionValues (plut√¥t que genome.actionValues) 
    // pour minimiser les modifs.
    calculateActionRules(cell, grid, x, y) {
        // Si la cellule n‚Äôa pas de actionValues, on sort directement.
        if (!cell.actionValues) {
            return;
        }
                
        const directions = ["N", "S", "E", "W"];
        const offsets = {
            N: [[x, y - 1], [x, y - 2], [x - 1, y - 1], [x + 1, y - 1]],
            S: [[x, y + 1], [x, y + 2], [x - 1, y + 1], [x + 1, y + 1]],
            E: [[x + 1, y], [x + 2, y], [x + 1, y - 1], [x + 1, y + 1]],
            W: [[x - 1, y], [x - 2, y], [x - 1, y - 1], [x - 1, y + 1]]
        };

        for (let i = 0; i < 4; i++) {
            const offsetCases = offsets[directions[i]];

            // √ânergie dans la direction
            cell.actionValues[i] = offsetCases.reduce((sum, [nx, ny]) => {
                const neighbor = grid[ny]?.[nx];
                if (!neighbor) return sum;

                // Si c‚Äôest une cellule vivante (state=1), on regarde 'energy'
                // Si c‚Äôest une cellule vide (state=0), on regarde 'energyLeft'
                if (neighbor.state === 0 && neighbor.energyLeft > 0) {
                    return sum + neighbor.energyLeft;
                }
                    return sum;
            }, 0);

            // Nombre de cellules dans la direction
            cell.actionValues[i + 4] = offsetCases.reduce((sum, pos) => {
                    const [nx, ny] = pos;
                    return sum + (grid[ny]?.[nx]?.state === 1 ? 1 : 0);
                }, 0);
        }
    }

    resolveMovementConflicts(movementIntents) {
      let conflictsExist = true;
      while (conflictsExist) {
        conflictsExist = false;
        let newMovementIntents = {};
        for (let targetKey in movementIntents) {
          const intents = movementIntents[targetKey];
          if (intents.length > 1) {
            conflictsExist = true;
            for (let intent of intents) {
              const { x, y, cell } = intent;
              if (`${x},${y}` === targetKey) {
                if (!newMovementIntents[targetKey]) {
                  newMovementIntents[targetKey] = [];
                }
                newMovementIntents[targetKey].push(intent);
              } else {
                const originalKey = `${x},${y}`;
                if (!newMovementIntents[originalKey]) {
                  newMovementIntents[originalKey] = [];
                }
                newMovementIntents[originalKey].push({ x, y, cell });
              }
            }
          } else {
            if (!newMovementIntents[targetKey]) {
              newMovementIntents[targetKey] = [];
            }
            newMovementIntents[targetKey].push(intents[0]);
          }
        }
        movementIntents = newMovementIntents;
      }
      this.applyMovements(movementIntents);
    }

    applyMovements(movementIntents) {
      for (const targetKey in movementIntents) {
        const intents = movementIntents[targetKey];
        const [targetX, targetY] = targetKey.split(',').map(Number);
        if (intents.length === 1) {
          const { x, y, cell } = intents[0];
          if (cell.state > 0) {
            if (cell.genome.moveRules.length > 0) {
              this.moveCell(x, y, targetX, targetY, cell, this.nextGrid);
            } else {
              this.nextGrid[targetY][targetX] = {
                age: cell.age,
                state: cell.state,
                genome: cell.genome,
                energy: cell.energy,
                energyLeft: 0
              };
            }
          } else {
            this.nextGrid[targetY][targetX] = {
              age: cell.age,
              state: cell.state,
              genome: null,
              energy: cell.energy,
              energyLeft: 0
            };
          }
        }
      }
    }

    moveCell(x, y, targetX, targetY, cell, nextGrid) {
      let energy = cell.energy;
      let moveRules = cell.genome.moveRules.slice();
      let targetCell = this.currentGrid[targetY][targetX];
      if (cell.genome.birth.length > 0) energy -= 0.5;
      if (energy <= 0) {
        this.cellDies(nextGrid, x, y, cell.genome.moveRules.length + cell.genome.birth.length + cell.genome.survivalRules.length);
      } else {
        energy += targetCell.energyLeft;
        if (energy > 200) energy = 200;
        // Gestion des mouvements
        const executedMove = moveRules.shift(); // Retire le premier mouvement de la pile
        if (executedMove >= 1 && executedMove <= 4) {
            // R√©empiler si le mouvement est hom√©ostatique
            moveRules.push(executedMove);
        }
        cell.genome.moveRules = moveRules;
        nextGrid[targetY][targetX] = { age: cell.age, state: 1, genome: cell.genome, energy: energy, energyLeft: 0 };

      }
    }

    // ------------------------------------------------
    //      REPRODUCTION, SURVIE & CROSSOVER
    // ------------------------------------------------

    handleSurvivalAndReproduction() {
      for (let y = 0; y < this.gridSize; y++) {
        for (let x = 0; x < this.gridSize; x++) {
          const cell = this.nextGrid[y][x];
          const cellLast = this.currentGrid[y][x];

          if (cellLast.state === -1) {
            this.nextGrid[y][x] = { ...cellLast };
            continue;
          }

          // Transfert d'√©nergieLeft si la case est vide
          if (cellLast.energyLeft > 0 && cell.state == 0) {
            this.nextGrid[y][x] = {
              state: 0,
              genome: null,
              energy: 0,
              energyLeft: cellLast.energyLeft,
              age: -1
            };
          }

          // Survie
          if (cell.state === 1) {
            if (cell.genome.birth[0]) cell.age += 1;
            const neighbors = this.countAliveNeighbors(this.currentGrid, x, y);
            const survivalRules = cell.genome.survivalRules;
            if (!survivalRules.includes(neighbors) && !cell.genome.birth.includes(neighbors)) {
              this.cellDies(this.nextGrid, x, y, cell.energy / 15);
            }
          }
          // Naissance
          else {
            const neighbors = this.getAliveNeighbors(this.currentGrid, x, y);
            const neighborsCount = neighbors.length;
            const compatibleNeighbors = neighbors.filter(c => c.genome.birth.includes(neighborsCount));
            if (compatibleNeighbors.length >= 2) {
              const parent1 = compatibleNeighbors[0];
              const parent2 = compatibleNeighbors[1];
              const childGenome = this.crossoverGenomes(
                parent1.genome,
                parent2.genome,
                parent1.energy,
                parent2.energy
              );
              let childEnergy = (parent1.energy + parent2.energy) / 2;
              this.nextGrid[y][x] = {
                state: 1,
                genome: childGenome,
                energy: childEnergy,
                energyLeft: 0,
                age: 0
              };
            }
          }
        }
      }
    }

    // -- Ajout du cross-over sur actionRules
    crossoverGenomes(genome1, genome2, energy1, energy2) {
      const childGenome = {
        survivalRules: [],
        birth: null,
        moveRules: [],
        actionRules: [] // <-- Modif : on ajoute actionRules
      };

      // Survie
      for (let i = 0; i < genome1.survivalRules.length; i++) {
        childGenome.survivalRules[i] = (Math.random() < 0.5)
          ? genome1.survivalRules[i] 
          : genome2.survivalRules[i];
      }

      // Naissance
      childGenome.birth = (Math.random() < 0.5)
        ? genome1.birth
        : genome2.birth;

      // MoveRules
      childGenome.moveRules = this.crossoverMoveRules(
        genome1.moveRules,
        genome2.moveRules,
        energy1, 
        energy2
      );

      // ActionRules : on m√©lange par index
      childGenome.actionRules = this.crossoverActionRules(
        genome1.actionRules || [],
        genome2.actionRules || []
      ); // <-- Modif

      return childGenome;
    }

    crossoverMoveRules(rules1, rules2, energy1, energy2) {
      const childRules = [];
      const maxLength = Math.max(rules1.length, rules2.length);
      for (let i = 0; i < maxLength; i++) {
        let instruction = null;
        const instr1 = rules1[i] || null;
        const instr2 = rules2[i] || null;
        const lowEnergy = (energy1 < 10 || energy2 < 10);
        const mutation = lowEnergy && Math.random() < 0.5;

        if (mutation) {
          if (instr1 !== null && instr2 !== null) {
            childRules.push(instr1);
            if (childRules.length < maxLength) childRules.push(instr2);
          } else if (instr1 !== null) {
            instruction = instr1;
          } else if (instr2 !== null) {
            instruction = instr2;
          }
        } else {
          if (instr1 !== null && instr2 !== null) {
            instruction = Math.random() < 0.5 ? instr1 : instr2;
          } else if (instr1 !== null) {
            instruction = instr1;
          } else if (instr2 !== null) {
            instruction = instr2;
          }
        }
        if (instruction !== null) {
          childRules.push(instruction);
        }
        if (childRules.length == maxLength) break;
      }
      return childRules;
    }

    // -- Nouveau : on croise les actionRules "case par case"
    crossoverActionRules(a1, a2) {  // <-- Modif
      const child = [];
      // Au cas o√π on n‚Äôait pas 8 cases, on s‚Äôaligne sur le max
      const length = Math.max(a1.length, a2.length, 8);
      for (let i = 0; i < length; i++) {
        const arr1 = a1[i] || [];
        const arr2 = a2[i] || [];
        // On choisit celui du parent1 ou parent2
        child[i] = (Math.random() < 0.5)
          ? [...arr1]
          : [...arr2];
      }
      return child;
    }

    // ------------------------------------------------
    //           DEEP CLONE DE LA CELLULE
    // ------------------------------------------------

    // -- Modif : on recopie aussi le genome.actionRules (clon√©)
    deepCloneCell(cell) {
      return {
        age: cell.age,
        state: cell.state,
        genome: cell.genome ? {
          survivalRules: [...cell.genome.survivalRules],
          birth: [...cell.genome.birth],
          moveRules: [...cell.genome.moveRules],
          actionRules: cell.genome.actionRules
            ? cell.genome.actionRules.map(rule => [...rule]) 
            : []
        } : null,
        energy: cell.energy,
        energyLeft: cell.energyLeft,
        actionValues: Array.isArray(cell.actionValues) ? [...cell.actionValues] : undefined // Conserve undefined si normal
      };
    }

    cellDies(grid, x, y, energyLeft) {
      grid[y][x] = {
        age: -1,
        state: 0,
        genome: null,
        energy: 0,
        energyLeft: grid[y][x].energyLeft + energyLeft,
        actionValues: Array(8).fill(0)
      };
    }

    // ------------------------------------------------
    //        VOISINAGE & DIVERS
    // ------------------------------------------------

    countAliveNeighbors(grid, x, y) {
      let count = 0;
      for (let j = -1; j <= 1; j++) {
        for (let i = -1; i <= 1; i++) {
          if (i === 0 && j === 0) continue;
          const nx = (x + i + this.gridSize) % this.gridSize;
          const ny = (y + j + this.gridSize) % this.gridSize;
          if (grid[ny][nx].state === 1) {
            count++;
          }
        }
      }
      return count;
    }

    getAliveNeighbors(grid, x, y) {
      const neighbors = [];
      for (let j = -1; j <= 1; j++) {
        for (let i = -1; i <= 1; i++) {
          if (i === 0 && j === 0) continue;
          const nx = (x + i + this.gridSize) % this.gridSize;
          const ny = (y + j + this.gridSize) % this.gridSize;
          if (grid[ny][nx].state === 1) {
            neighbors.push(grid[ny][nx]);
          }
        }
      }
      return neighbors;
    }

    getDirectionOffset(dir) {
      switch (dir) {
        case 1: case 5: return [0, -1]; // North
        case 2: case 6: return [0, 1];  // South
        case 3: case 7: return [1, 0];  // East
        case 4: case 8: return [-1, 0]; // West
        default: return [0, 0];
      }
    }

    // ------------------------------------------------
    //     GRAPHIQUES : courbes population / √©nergie
    // ------------------------------------------------

    updateGraphData() {
      let population = 0;
      let totalEnergy = 0;
      for (let y = 0; y < this.gridSize; y++) {
        for (let x = 0; x < this.gridSize; x++) {
          const cell = this.currentGrid[y][x];
          if (cell.state === 1) {
            population++;
            totalEnergy += cell.energy;
          }
          totalEnergy += cell.energyLeft;
        }
      }
      this.populationCounts.push(population);
      this.energyCounts.push(totalEnergy / 50);
      if (this.populationCounts.length > this.maxGenerations) {
        this.populationCounts.shift();
        this.energyCounts.shift();
      }
    }

    drawGraph() {
      this.graphCtx.clearRect(0, 0, this.graphCanvas.width, this.graphCanvas.height);
      const maxPopulation = this.gridSize * this.gridSize;
      const maxEnergy = this.gridSize * this.gridSize * 4.2;
      const scaleX = this.graphCanvas.width / this.maxGenerations;
      const scaleYPopulation = this.graphCanvas.height / maxPopulation;
      const scaleYEnergy = this.graphCanvas.height / maxEnergy;

      // Courbe population
      this.graphCtx.beginPath();
      this.graphCtx.strokeStyle = '#0000FF';
      for (let i = 0; i < this.populationCounts.length; i++) {
        const x = i * scaleX;
        const y = this.graphCanvas.height - this.populationCounts[i] * scaleYPopulation;
        if (i === 0) this.graphCtx.moveTo(x, y);
        else this.graphCtx.lineTo(x, y);
      }
      this.graphCtx.stroke();

      // Courbe √©nergie
      this.graphCtx.beginPath();
      this.graphCtx.strokeStyle = '#FF0000';
      for (let i = 0; i < this.energyCounts.length; i++) {
        const x = i * scaleX;
        const y = this.graphCanvas.height - this.energyCounts[i] * scaleYEnergy;
        if (i === 0) this.graphCtx.moveTo(x, y);
        else this.graphCtx.lineTo(x, y);
      }
      this.graphCtx.stroke();
    }

    // ------------------------------------------------
    //       EVENTS & INTERACTIONS
    // ------------------------------------------------

    bindEvents() {
      document.getElementById('Reset').addEventListener('click', (event) => {
        this.openResetModal();
        event.target.blur();
      });
      document.getElementById('clear').addEventListener('click', (event) => {
        this.clearGrid();
        event.target.blur();
      });
      document.getElementById('seed').addEventListener('change', (event) => {
        this.changeSeed(event);
        event.target.blur();
      });
      document.getElementById('board').addEventListener('change', (event) => {
        this.resizeBoard(event);
        event.target.blur();
      });
      document.addEventListener('keydown', (event) => this.handleKeyDown(event));

      // Event listeners for the reset modal
      this.applyResetButton.addEventListener('click', (event) => {
        this.applyReset();
        event.target.blur();
      });
      this.cancelResetButton.addEventListener('click', (event) => {
        this.closeResetModal();
        event.target.blur();
      });

      // Mouse events for cell selection
      this.gameCanvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
      this.gameCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
      this.gameCanvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
      this.gameCanvas.addEventListener('click', (e) => this.handleClick(e));
      this.gameCanvas.addEventListener('mouseout', () => this.handleMouseOut());

      // Copy button event
      this.copyButton.addEventListener('click', (event) => {
        this.copySelectedArea();
        event.target.blur();
      });

      // Draggable copied areas
      this.copiedAreaDiv.addEventListener('mousedown', (event) => this.handleCopiedAreaMouseDown(event));
    }

    resetGame() {
      this.initGame();
    }

    clearGrid() {
        if (this.selectedArea) {
            const { x1, y1, x2, y2 } = this.selectedArea;
            for (let y = y1; y <= y2; y++) {
                for (let x = x1; x <= x2; x++) {
                    if (this.currentGrid[y][x].state !== -1) {
                      this.currentGrid[y][x] = this.createEmptyCell();
                    }
                }
            }
            this.clearSelection();
        } else {
            for (let y = 0; y < this.gridSize; y++) {
                for (let x = 0; x < this.gridSize; x++) {
                    if (this.currentGrid[y][x].state !== -1) {
                      this.currentGrid[y][x] = this.createEmptyCell();
                    }
                }
            }
        }
        this.nextGrid = this.copyGrid(this.currentGrid);
        this.drawGrid(this.currentGrid);
    }

    changeSeed(event) {
      this.seed = event.target.value;
      this.initGame();
      event.target.blur();
    }

    resizeBoard(event) {
      const newSize = parseInt(event.target.value);
      this.resizeGameBoard(newSize);
      event.target.blur();
    }

    resizeGameBoard(newSize) {
      const oldSize = this.gridSize;
      this.gridSize = newSize;
      const newGrid = this.createGrid(newSize);
      const offset = Math.floor((newSize - oldSize) / 2);
      for (let y = 0; y < oldSize; y++) {
        for (let x = 0; x < oldSize; x++) {
          const newY = y + offset;
          const newX = x + offset;
          if (newY >= 0 && newY < newSize && newX >= 0 && newX < newSize) {
            newGrid[newY][newX] = this.currentGrid[y][x];
          }
        }
      }
      this.currentGrid = newGrid;
      this.cellSize = this.gameCanvas.width / this.gridSize;
      this.drawGrid(this.currentGrid);
    }

    handleKeyDown(event) {
      if (event.key === '+') {
        this.adjustSpeed(1);
      } else if (event.key === '-') {
        this.adjustSpeed(-1);
      } else if (event.code === 'Space') {
        this.togglePause();
      }
    }

    adjustSpeed(direction) {
      if (!this.isPaused) {
        if (direction == -1)
          this.speed += direction * (this.speed <= 100 ? 10 : (this.speed <= 1000 ? 100 : 1000));
        else
          this.speed += direction * (this.speed < 100 ? 10 : (this.speed < 1000 ? 100 : 1000));
        this.speed = (this.speed < 10 ? 10 : (this.speed > 5000 ? 5000 : this.speed));
        document.getElementById('speed').value = this.speed;
      }
    }

    togglePause() {
      this.isPaused = !this.isPaused;
      if (this.isPaused) {
        document.getElementById('speed').value = 'PAUSE';
      } else {
        document.getElementById('speed').value = this.speed;
      }
    }

    // ------------------------------------------------
    //     S√âLECTION ET INTERACTIONS SOURIS
    // ------------------------------------------------

    handleMouseMove(event) {
      const rect = this.gameCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      const cellX = Math.floor(mouseX / this.cellSize);
      const cellY = Math.floor(mouseY / this.cellSize);

      if (this.isDragging && this.draggedArea) {
        const { width, height } = this.draggedArea;
        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);

        let isValid = true;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tx = (cellX + x) % this.gridSize;
            const ty = (cellY + y) % this.gridSize;
            if (this.currentGrid[ty][tx].state !== 0) {
              isValid = false;
              break;
            }
          }
          if (!isValid) break;
        }
        this.overlayCtx.fillStyle = isValid
          ? 'rgba(0, 255, 0, 0.5)'
          : 'rgba(255, 0, 255, 0.5)';
        this.overlayCtx.fillRect(
          cellX * this.cellSize,
          cellY * this.cellSize,
          width * this.cellSize,
          height * this.cellSize
        );
      } else {
        this.hoveredCell = { x: cellX, y: cellY };
        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        if (this.hoveredCell) {
          this.overlayCtx.strokeStyle = 'grey';
          this.overlayCtx.setLineDash([]);
          this.overlayCtx.strokeRect(
            this.hoveredCell.x * this.cellSize,
            this.hoveredCell.y * this.cellSize,
            this.cellSize, this.cellSize
          );
        }
      }

      if (this.isSelecting) {
        this.endX = Math.trunc(mouseX / this.cellSize);
        this.endY = Math.trunc(mouseY / this.cellSize);

        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);

        let width = (this.endX - this.startX + 1);
        let height = (this.endY - this.startY + 1);

        this.overlayCtx.setLineDash([8, 4]);
        this.overlayCtx.strokeStyle = 'black';

        if (width <= 0) width = width * -1 + 2;
        if (height <= 0) height = height * -1 + 2;

        this.overlayCtx.strokeRect(
          (this.endX < this.startX ? this.endX : this.startX) * this.cellSize,
          (this.endY < this.startY ? this.endY : this.startY) * this.cellSize,
          width * this.cellSize,
          height * this.cellSize
        );
      }
    }

    handleMouseDown(event) {
      const rect = this.gameCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      this.startX = Math.trunc(mouseX / this.cellSize);
      this.startY = Math.trunc(mouseY / this.cellSize);

      this.isSelecting = true;
      this.selectedArea = null;
      this.isAreaSelected = false;

      this.stopAnimation();
    }

    handleMouseUp(event) {
      event.preventDefault();

      const rect = this.gameCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      const cellX = Math.floor(mouseX / this.cellSize);
      const cellY = Math.floor(mouseY / this.cellSize);

      this.endX = cellX;
      this.endY = cellY;

      if (this.isSelecting) {
        this.isSelecting = false;

        if (this.startX === this.endX && this.startY === this.endY) {
          this.selectedArea = { x1: this.startX, y1: this.startY, x2: this.startX, y2: this.startY };
          this.isAreaSelected = false;
        } else {
          const x1 = Math.min(this.startX, this.endX);
          const y1 = Math.min(this.startY, this.endY);
          const x2 = Math.max(this.startX, this.endX);
          const y2 = Math.max(this.startY, this.endY);
          this.selectedArea = { x1, y1, x2, y2 };
          this.isAreaSelected = true;
        }

        this.displaySelectionInfo(
          this.selectedArea.x1, this.selectedArea.y1,
          this.selectedArea.x2, this.selectedArea.y2
        );
        this.infoDiv.style.display = 'inline-block';
        this.startAnimation();
        this.startX = this.startY = this.endX = this.endY = null;
      }
      else if (this.isDragging && this.draggedArea) {
        const { width, height } = this.draggedArea;
        let isValid = true;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const tx = (cellX + x) % this.gridSize;
            const ty = (cellY + y) % this.gridSize;
            if (this.currentGrid[ty][tx].state !== 0) {
              isValid = false;
              break;
            }
          }
          if (!isValid) break;
        }

        if (isValid) {
          for (let yy = 0; yy < height; yy++) {
            for (let xx = 0; xx < width; xx++) {
              const targetX = (cellX + xx) % this.gridSize;
              const targetY = (cellY + yy) % this.gridSize;
              const copiedCell = this.draggedArea.gridData[yy][xx];
              this.currentGrid[targetY][targetX] = { ...copiedCell };
            }
          }
          this.drawGrid(this.currentGrid);
        }
        this.nextGrid = this.copyGrid(this.currentGrid);
        this.isDragging = false;
        this.draggedArea = null;
        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
      }
    }

    handleClick(event) {
      const rect = this.gameCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      const cellX = Math.floor(mouseX / this.cellSize);
      const cellY = Math.floor(mouseY / this.cellSize);

      if (this.selectedCell && this.selectedCell.x === cellX && this.selectedCell.y === cellY) {
        this.clearSelection();
        this.infoDiv.style.display = 'none';
      } else {
        this.selectedCell = { x: cellX, y: cellY };
        this.displayCellInfo(cellX, cellY);
        this.infoDiv.style.display = 'inline-block';
        this.startAnimation();
      }
      this.drawGrid(this.currentGrid);
    }

    handleMouseOut() {
      this.hoveredCell = null;
      this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
    }

    // ------------------------------------------------
    //     S√âLECTION (AFFICHAGE DES INFOS)
    // ------------------------------------------------

    clearSelection() {
      this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
      this.selectedCell = null;
      this.selectedArea = null;
      this.isAreaSelected = false;
      this.stopAnimation();

      this.CellInfoContent.innerHTML = '';
      this.survivalColumn.innerHTML = '';
      this.birthColumn.innerHTML = '';
      this.moveColumn.innerHTML = '';

      this.infoDiv.style.display = 'none';
    }

    startAnimation() {
      if (!this.isAnimationRunning) {
        this.isAnimationRunning = true;
        this.idAnim = requestAnimationFrame(() => this.animateDashedBorder());
      }
    }

    stopAnimation() {
      this.isAnimationRunning = false;
      cancelAnimationFrame(this.idAnim);
      this.idAnim = null;
    }

    animateDashedBorder() {
      this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);

      if (this.selectedArea) {
        this.overlayCtx.setLineDash([8, 4]);
        this.overlayCtx.lineDashOffset = this.dashOffset;
        this.overlayCtx.strokeStyle = 'black';

        const x = this.selectedArea.x1 * this.cellSize;
        const y = this.selectedArea.y1 * this.cellSize;
        const width = (this.selectedArea.x2 - this.selectedArea.x1 + 1) * this.cellSize;
        const height = (this.selectedArea.y2 - this.selectedArea.y1 + 1) * this.cellSize;
        this.overlayCtx.strokeRect(x, y, width, height);
      }

      if (this.hoveredCell) {
        this.overlayCtx.setLineDash([]);
        this.overlayCtx.strokeStyle = 'grey';
        this.overlayCtx.strokeRect(
          this.hoveredCell.x * this.cellSize,
          this.hoveredCell.y * this.cellSize,
          this.cellSize, this.cellSize
        );
      }

      this.dashOffset += 1;
      if (this.isAnimationRunning) {
        requestAnimationFrame(() => this.animateDashedBorder());
      }
    }

    displaySelectionInfo(x1, y1, x2, y2) {
      let liveCells = 0, deadCells = 0, totalEnergy = 0, totalAge = 0;
      let totalSurvivalRules = 0, totalBirthRules = 0, totalMoveRules = 0;

      for (let yy = y1; yy <= y2; yy++) {
        for (let xx = x1; xx <= x2; xx++) {
          const cell = this.currentGrid[yy][xx];
          if (cell.state === 1) {
            liveCells++;
            totalEnergy += cell.energy;
            totalAge += cell.age;
            totalSurvivalRules += cell.genome.survivalRules.length;
            totalBirthRules += cell.genome.birth.length;
            totalMoveRules += cell.genome.moveRules.length;
          } else {
            deadCells++;
            totalEnergy += cell.energyLeft;
          }
        }
      }

      const averageAge = liveCells > 0 ? (totalAge / liveCells).toFixed(2) : 'N/A';
      const totalRules = totalSurvivalRules + totalBirthRules + totalMoveRules;

      document.getElementsByClassName('CellInfoTitle')[0].innerHTML = 'üî≤ S√©lection';

      const headerTable = `
        <table width="100%">
          <tr><td>Surface</td><td>${(Math.abs(x1 - x2) + 1) * (Math.abs(y1 - y2) + 1)} cases</td></tr>
          <tr><td>Population</td><td>${liveCells} ${liveCells > 0 ? 'üü•' : ''}</td></tr>
          <tr><td>√Çge Moyen</td><td>${averageAge}</td></tr>
          <tr><td>√ânergie</td><td>${totalEnergy.toFixed(2)} </td></tr>
          <tr><td>Codes</td><td>${totalRules}</td></tr>
        </table>
      `;
      this.CellInfoContent.innerHTML = headerTable;

      this.cellProxy.innerHTML = '';
      this.genomeInfo.style.display = 'none';

      if (liveCells > 0 || totalEnergy > 0) {
        this.copyButton.style.display = 'block';
      } else {
        this.copyButton.style.display = 'none';
      }
    }

    displayCellInfo(x, y) {
        if (this.isAreaSelected) {
            return;
        }

        const cell = this.currentGrid[y][x];
        this.CellInfoContent.innerHTML = '';
        this.cellProxy.innerHTML = '';
        this.survivalColumn.innerHTML = '';
        this.birthColumn.innerHTML = '';
        this.moveColumn.innerHTML = '';

        const neighborsCount = this.countAliveNeighbors(this.currentGrid, x, y);
        const actionSection = document.getElementById('actionSection');
        const actionColumn  = document.getElementById('actionColumn');
        // Remettre √† vide ou masquer avant de remplir
        actionColumn.innerHTML = '';
        actionSection.style.display = 'none';

        let stateText = cell.state === 1
        ? 'üü• Living cell'
        : (cell.energyLeft > 0 ? 'üü©Ô∏è Energy' : 'Vide');

        let ageText = cell.state === 1 ? cell.age : '';
        let energyText = cell.state === 1 ? cell.energy : cell.energyLeft;

        document.getElementsByClassName('CellInfoTitle')[0].innerHTML = 'üö© Location';

        const headerTable = `
        <table width="100%">
            <tr><td>Position</td><td>(${x}, ${y})</td></tr>
            <tr><td>Type</td><td>${stateText}</td></tr>
            <tr><td>Age</td><td>${ageText}</td></tr>
            <tr><td>Energy</td><td>${energyText.toFixed(2)}</td></tr>
            <tr><td>Neighbors</td><td>${neighborsCount}</td></tr>
        </table>
        `;
        this.CellInfoContent.innerHTML = headerTable;

        if (cell.state === 1 && cell.genome) {
            this.genomeInfo.style.display = 'block';

            // Survival Rules et Birth Rules 
            this.appendGenomeElements(this.survivalColumn, cell.genome.survivalRules, 'survival', 'S');
            this.appendGenomeElements(this.birthColumn, cell.genome.birth, 'birth', 'B');
            
            // MoveRules
            if (cell.genome.moveRules && cell.genome.moveRules.length > 0) {
                document.getElementById('moveSection').style.display = 'block';
                this.appendGenomeElements(this.moveColumn, cell.genome.moveRules, 'move', 'M', this.getArrowForDirection);
            } else {
                document.getElementById('moveSection').style.display = 'none';
            }

            // ActionRules
            if (cell.genome.actionRules && cell.genome.actionRules.length > 0) {
                // On rend visible la section
                actionSection.style.display = 'block';
                // On remplit la section
                this.displayActionRules(cell.genome.actionRules, actionColumn);
            } else {
                // Sinon on cache
                actionSection.style.display = 'none';
            }
        } else {
            this.genomeInfo.style.display = 'none';
        }

        this.displayBirthCompetition(x, y, neighborsCount);
    }

    displayActionRules(actionRules, container) {
        // Nettoyage
        container.innerHTML = '';

        const directions = ['N', 'S', 'E', 'W'];
        const moveArrows = { N: '‚ñ≤', S: '‚ñº', E: '‚ñ∂', W: '‚óÄ' }; 
        for (let i = 0; i < actionRules.length; i++) {
            const ruleArr = actionRules[i]; // Les mouvements associ√©s √† cet actionRule
            const isEnergyRule = i < 4;     // Les 4 premi√®res r√®gles concernent l‚Äô√©nergie
            const direction = directions[i % 4];
            const emoji = isEnergyRule ? 'üü©Ô∏è' : 'üü•';

            // Afficher l'ActionRule (√©nergie ou cellule)
            const ruleDiv = document.createElement('div');
            ruleDiv.classList.add('gene', 'actionRule', isEnergyRule ? 'energy' : 'cell');
            ruleDiv.innerHTML = `${emoji}${direction}`;
            container.appendChild(ruleDiv);

            // Afficher les mouvements associ√©s (s'il y en a)
            ruleArr.forEach((move) => {
                const moveDiv = document.createElement('div');
                moveDiv.classList.add('gene', 'tmp_move');
                moveDiv.innerHTML = `M${moveArrows[directions[(move - 1) % 4]]}`; // Convertir move en fl√®che
                container.appendChild(moveDiv);
            });
        }
    }

    displayBirthCompetition(x, y, neighborsCount) {
      const cellProxy = this.cellProxy;
      const neighbors = this.getAliveNeighbors(this.currentGrid, x, y);
      const compatibleNeighbors = neighbors.filter(
        c => c.genome.birth.includes(neighborsCount)
      );

      if (compatibleNeighbors.length > 0) {
        cellProxy.innerHTML = '';
        cellProxy.style.display = 'block';

        const competitionTitle = document.createElement('div');
        competitionTitle.innerHTML = '<strong>Comp√©tition pour l\'emplacement</strong>';
        cellProxy.appendChild(competitionTitle);

        compatibleNeighbors.forEach((neighbor, index) => {
          const neighborX = (x + (index % 3) - 1 + this.gridSize) % this.gridSize;
          const neighborY = (y + Math.floor(index / 3) - 1 + this.gridSize) % this.gridSize;

          const neighborDiv = document.createElement('div');
          neighborDiv.innerHTML = `(${neighborX}, ${neighborY}) : `;
          neighborDiv.style.display = 'inline-block';

          neighbor.genome.birth.forEach(birthRule => {
            const birthDiv = document.createElement('div');
            birthDiv.textContent = `B${birthRule}`;
            birthDiv.classList.add('gene-small', 'birth');
            neighborDiv.appendChild(birthDiv);
          });

          cellProxy.appendChild(neighborDiv);
        });
      } else {
        cellProxy.style.display = 'none';
      }
    }

    appendGenomeElements(container, rules, className, prefix, formatFn = (r) => r) {
      rules.forEach(rule => {
        this.appendGenomeElement(container, formatFn(rule), className, prefix);
      });
    }

    appendGenomeElement(container, value, className, prefix) {
      const elementDiv = document.createElement('div');
      elementDiv.textContent = `${prefix}${value}`;
      elementDiv.classList.add('gene', className);
      container.appendChild(elementDiv);
    }

    getArrowForDirection(dir) {
      switch (dir) {
        case 1: case 5: return '‚ñ≤'; // '‚áß';
        case 2: case 6: return '‚ñº'; // '‚á©';
        case 3: case 7: return '‚ñ∂'; //'‚á®';
        case 4: case 8: return '‚óÄ'; //'‚á¶';
        default: return '?';
      }
    }

    copySelectedArea() {
      if (!this.selectedArea) return;
      const { x1, y1, x2, y2 } = this.selectedArea;

      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');

      const width = (x2 - x1 + 1) * this.cellSize;
      const height = (y2 - y1 + 1) * this.cellSize;
      tempCanvas.width = width;
      tempCanvas.height = height;

      this.clearSelection();
      tempCtx.drawImage(
        this.gameCanvas,
        x1 * this.cellSize, y1 * this.cellSize, width, height,
        0, 0, width, height
      );

      const img = new Image();
      img.src = tempCanvas.toDataURL();
      img.style.width = '50px';
      img.style.height = '50px';
      img.style.margin = '5px';
      img.style.cursor = 'pointer';

      const imgContainer = document.createElement('div');
      imgContainer.appendChild(img);
      imgContainer.style.display = 'inline-block';
      imgContainer.draggable = true;

      this.copiedAreaDiv.appendChild(imgContainer);

      const gridData = [];
      for (let yy = y1; yy <= y2; yy++) {
        const row = [];
        for (let xx = x1; xx <= x2; xx++) {
          row.push(this.deepCloneCell(this.currentGrid[yy][xx]));
        }
        gridData.push(row);
      }

      const copiedData = {
        x1, y1, x2, y2,
        image: img.src,
        aliveCount: this.countAliveCells(x1, y1, x2, y2),
        totalEnergy: this.calculateTotalEnergy(x1, y1, x2, y2),
        width: x2 - x1 + 1,
        height: y2 - y1 + 1,
        gridData
      };
      this.copiedAreas.push(copiedData);

      imgContainer.addEventListener('mousedown', (event) => {
        event.preventDefault();
        this.clearSelection();
        this.draggedArea = copiedData;
        this.isDragging = true;
      });
    }

    countAliveCells(x1, y1, x2, y2) {
      let aliveCount = 0;
      for (let yy = y1; yy <= y2; yy++) {
        for (let xx = x1; xx <= x2; xx++) {
          if (this.currentGrid[yy][xx].state === 1) {
            aliveCount++;
          }
        }
      }
      return aliveCount;
    }

    calculateTotalEnergy(x1, y1, x2, y2) {
      let totalEnergy = 0;
      for (let yy = y1; yy <= y2; yy++) {
        for (let xx = x1; xx <= x2; xx++) {
          const cell = this.currentGrid[yy][xx];
          if (cell.state === 1) {
            totalEnergy += cell.energy;
          } else if (cell.state === 0 && cell.energyLeft > 0) {
            totalEnergy += cell.energyLeft;
          }
        }
      }
      return totalEnergy;
    }

    handleCopiedAreaMouseDown(event) {
      if (event.target.tagName === 'IMG') {
        const index = [...event.target.parentElement.parentElement.children]
          .indexOf(event.target.parentElement);
        this.draggedArea = this.copiedAreas[index];
        this.isDragging = true;
      }
    }

    // ------------------------------------------------
    //        GENOMES & PATTERNS (EXISTANTS)
    // ------------------------------------------------

    defineGenomes() {
      this.genomeTypes = {
        1: () => ({ survivalRules: [2, 3], birth: [3], moveRules: [], actionRules: [] }),
        2: () => ({ survivalRules: [2, 3], birth: [3], moveRules: [1, 1, 3, 3], actionRules: [] }),
        3: () => ({ survivalRules: [2, 3], birth: [4], moveRules: [1, 1, 3, 3], actionRules: [] }),
        4: () => ({ survivalRules: [3, 4], birth: [3, 4], moveRules: [], actionRules: [] }),
        5: () => ({ survivalRules: [2, 4], birth: [2], moveRules: [], actionRules: [] }),
        9: () => ({ survivalRules: [2, 3], birth: [3], moveRules: [], actionRules: [[5], [6], [7], [8], [5], [6], [7], [8]], actionValues: Array(8).fill(0)})
      };
    }

    getGenome(type) {
        const genome = this.genomeTypes[type]
            ? this.genomeTypes[type]()
            : this.generateRandomGenome();
        console.log(`Genome for type ${type}:`, genome); // V√©rifie les actionRules ici
        return genome;
    }

    definePatterns() {
      this.patterns = [
        {
          name: 'Pattern 1',
          data: [
            [0, 1, 1],
            [1, 0, 1],
            [1, 0, 1],
            [0, 1, 0]
          ]
        },
        {
          name: 'Pattern 2',
          data: [
            [1, 0, 0],
            [1, 0, 1],
            [1, 1, 0]
          ]
        },
        {
          name: 'Pattern 3',
          data: [
            [3, 3],
            [3, 3]
          ]
        },
        {
          name: 'Pattern 4',
          data: [
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1],
            [1, 0, 0, 0, 1],
            [0, 1, 1, 1, 1]
          ]
        },
        {
          name: 'Pattern 5',
          data: [
            [1, 1, 1, 0, 0, 0],
            [0, 1, 0, 1, 1, 1],
            [1, 1, 0, 1, 1, 0],
            [1, 1, 0, 1, 1, 0],
            [0, 0, 1, 0, 0, 0]
          ]
        },
        {
          name: 'Pattern 6',
          data: [
            [1, 4, 5, 5, 4, 1]
          ]
        },
        {
          name: 'Pattern 7',
          data: [
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1],
            [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],
            [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]
          ]
        },
        {
          name: 'Pattern 8',
          data: [
            [0, 1, 1, 0, 0, 0],
            [0, 0, 0, 1, 1, 0],
            [1, 1, 0, 0, 0, 0],
            [0, 0, 1, 1, 1, 0]
          ]
        },
        {
          name: 'Pattern 9',
          data: [
            [9, 9],
            [9, 9]
          ]
        }
      ];
    }

    preloadPatterns() {
      this.patterns.forEach(pattern => {
        this.preloadPattern(pattern.data, pattern.name);
      });
    }

    preloadPattern(motif, patternName) {
        const width = motif[0].length;
        const height = motif.length;

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width * this.cellSize;
        tempCanvas.height = height * this.cellSize;

        const gridData = [];
        for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
                const cellType = motif[y][x];
                const cell = {
                    state: (cellType > 0 ? 1 : 0),
                    genome: cellType > 0 ? this.getGenome(cellType) : null,
                    energy: cellType > 0 ? 100 : 0,
                    age: cellType > 0 ? 0 : -1,
                    energyLeft: 0,
                    actionValues: Array(8).fill(0)
                };
                
                console.log(`Cell created for type ${cellType}:`, cell);

                row.push(cell);
                if (cell.state === 1) {
                    tempCtx.fillStyle = cell.genome.moveRules.length > 0 ? 'orange' : 'red';
                    tempCtx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                }
            }
            gridData.push(row);
        }

        const img = new Image();
        img.src = tempCanvas.toDataURL();
        img.style.width = '50px';
        img.style.height = '50px';
        img.style.margin = '5px';
        img.style.cursor = 'pointer';
        img.title = patternName;

        const imgContainer = document.createElement('div');
        imgContainer.appendChild(img);
        imgContainer.style.display = 'inline-block';
        imgContainer.draggable = true;

        this.copiedAreaDiv.appendChild(imgContainer);

        const copiedData = {
            x1: 0,
            y1: 0,
            x2: width - 1,
            y2: height - 1,
            image: img.src,
            aliveCount: motif.flat().filter(cell => cell > 0).length,
            totalEnergy: motif.flat().filter(cell => cell > 0).length * 100,
            width: width,
            height: height,
            gridData
        };
        this.copiedAreas.push(copiedData);

        imgContainer.addEventListener('mousedown', (event) => {
            event.preventDefault();
            this.draggedArea = copiedData;
            this.isDragging = true;
        });
    }

    // ------------------------------------------------
    //      RESET MODAL & PRE-ENREGISTRED WORLDS
    // ------------------------------------------------

    openResetModal() {
      this.currentSeedOption.textContent = this.seed;
      if (!isNaN(this.seed) && this.seed !== "") {
        document.getElementById('currentOption').checked = true;
      } else {
        document.getElementById('randomOption').checked = true;
      }
      this.resetModal.style.display = 'flex';
    }

    closeResetModal() {
      this.resetModal.style.display = 'none';
    }

    applyReset() {
      const selectedOption = this.resetForm.querySelector('input[name="seedOption"]:checked').value;
      if (selectedOption === 'random') {
        this.seed = Math.floor(Math.random() * 100000);
        document.getElementById('seed').value = this.seed;
        this.initGame();
      } else if (selectedOption === 'current') {
        this.seed = parseInt(this.currentSeedOption.textContent, 10);
        document.getElementById('seed').value = this.seed;
        this.initGame();
      } else {
        const worldId = parseInt(selectedOption, 10);
        const world = this.worlds[worldId];
        if (world) {
          this.seed = world.name;
          document.getElementById('seed').value = this.seed;
          this.initializeGridWithWorld(world.grid);
          this.drawGrid(this.currentGrid);
        } else {
          console.error(`World with ID ${worldId} not found.`);
        }
      }
      this.closeResetModal();
    }

    initializeGridWithWorld(grid) {
      this.currentGrid = this.createGrid(this.gridSize);
      this.nextGrid = this.createGrid(this.gridSize);

      const offsetY = Math.floor((this.gridSize - grid.length) / 2);
      const offsetX = Math.floor((this.gridSize - grid[0].length) / 2);

      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
          const newY = y + offsetY;
          const newX = x + offsetX;
          if (newY >= 0 && newY < this.gridSize && newX >= 0 && newX < this.gridSize) {
            this.currentGrid[newY][newX].state = grid[y][x];
            if (grid[y][x] > 0) {
              this.currentGrid[newY][newX].energy = 100;
              this.currentGrid[newY][newX].genome =
                (this.genomeTypes[grid[y][x]] || (() => null))();
            }
          }
        }
      }
    }
  }

  // Lance la simulation
  const game = new GameOfLife();
</script>
</body>
</html>
